<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tu on Mezalor</title>
    <link>http://example.org/tags/tu/</link>
    <description>Recent content in tu on Mezalor</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <lastBuildDate>Tue, 18 Dec 2018 11:59:00 +0100</lastBuildDate><atom:link href="http://example.org/tags/tu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>java, forcer l&#39;ordre d&#39;exécution des tests unitaires</title>
      <link>http://example.org/posts/2018-12-18-java-forcer-l-ordre-d-execution-des-tests-unitaires/</link>
      <pubDate>Tue, 18 Dec 2018 11:59:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2018-12-18-java-forcer-l-ordre-d-execution-des-tests-unitaires/</guid>
      <description>Parfois, des tests unitaires plantent lorsqu&amp;rsquo;ils sont exécutés dans un certain ordre.
Aujourd&amp;rsquo;hui, c&amp;rsquo;est le cas et pour reproduire le problème, j&amp;rsquo;ai utilisé cette annotation qui permet de spécifier l&amp;rsquo;ordre que l&amp;rsquo;on souhaite utiliser lors de l&amp;rsquo;exécution de tous les tests de la classe.
import org.junit.FixMethodOrder; import org.junit.Test; import org.junit.runners.MethodSorters; @FixMethodOrder(MethodSorters.NAME_ASCENDING) public class TestMethodOrder { @Test public void testA() { System.out.println(&amp;#34;first&amp;#34;); } @Test public void testB() { System.out.println(&amp;#34;second&amp;#34;); } @Test public void testC() { System.</description>
    </item>
    
    <item>
      <title>java, mockito espionner le retour d&#39;une fonction</title>
      <link>http://example.org/posts/2016-02-18-java-mockito-espionner-le-retour-d-une-fonction/</link>
      <pubDate>Thu, 18 Feb 2016 09:42:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-02-18-java-mockito-espionner-le-retour-d-une-fonction/</guid>
      <description>Le code n&amp;rsquo;est pas beau, mais au moins il est copiable directement en test unitaire pour manipuler et tester !
@Test public void testFoo() throws Exception { class ResultCaptor implements Answer&amp;lt;String&amp;gt; { private String result; String getResult() { return result; } @Override public String answer(InvocationOnMock invocationOnMock) throws Throwable { result = (String) invocationOnMock.callRealMethod(); return result; } } class MyClazz { public String f(String param) { return &amp;#34;out=&amp;#34; + param; } } MyClazz a = new MyClazz(); MyClazz spy = spy(a); ResultCaptor answer = new ResultCaptor(); when(spy.</description>
    </item>
    
  </channel>
</rss>
