<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>commande on Mezalor</title>
    <link>http://example.org/tags/commande/</link>
    <description>Recent content in commande on Mezalor</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <lastBuildDate>Thu, 16 Sep 2021 10:07:00 +0100</lastBuildDate><atom:link href="http://example.org/tags/commande/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>miller, traiter les fichiers CSV (et autres) en ligne de commande</title>
      <link>http://example.org/posts/2021-09-16-miller-traiter-les-fichiers-csv-et-autres-en-ligne-de-commande/</link>
      <pubDate>Thu, 16 Sep 2021 10:07:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2021-09-16-miller-traiter-les-fichiers-csv-et-autres-en-ligne-de-commande/</guid>
      <description>Hier, j&amp;rsquo;ai découvert le programme mlr (https://github.com/johnkerl/miller)
Il est installable par apt sous ubuntu.
Il permet d&amp;rsquo;effectuer des traitements sur les fichiers dont les données sont indexées par nom
name-indexed data such as CSV, TSV, and tabular JSON
La documentation semble bien étoffée: https://miller.readthedocs.io/en/latest/index.html
$ wget https://www.data.gouv.fr/fr/datasets/r/de7d0863-13e8-4010-9c75-487269f5d7ac -O depts.csv ... depts.csv 100%[=====================================================================================================================&amp;gt;] 3,25K --.-KB/s ds 0,01s ... $ cat depts.csv | head -n 2 code_departement,nom_departement,code_region,nom_region 1,Ain,84,Auvergne-Rhône-Alpes $ cat depts.csv | tail -n 2 974,La Réunion,4,La Réunion 976,Mayotte,6,Mayotte $ mlr --icsv --from depts.</description>
    </item>
    
    <item>
      <title>bash, appel callback à la sortie...</title>
      <link>http://example.org/posts/2020-11-20-bash-appel-callback-a-la-sortie/</link>
      <pubDate>Fri, 20 Nov 2020 17:20:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2020-11-20-bash-appel-callback-a-la-sortie/</guid>
      <description>Il est possible en bash d&amp;rsquo;appeler des méthodes lorsque de la fin du script est atteinte et ce même s&amp;rsquo;il y a une erreur.
Ci-dessous, le script appellera cleanup_err puis cleanup_ok lorsque false sera atteint.
#!/bin/bash function cleanup_err { echo cleanup_err } function cleanup_ok { echo cleanup_ok } trap cleanup_ok EXIT trap cleanup_err ERR C&amp;rsquo;est bien pratique pour nettoyer les fichiers et répertoires temporaires :)</description>
    </item>
    
    <item>
      <title>tmux, copier/coller à la vi &#43; dans le presse-papier</title>
      <link>http://example.org/posts/2020-11-18-tmux-copier-coller-a-la-vi-&#43;-dans-le-presse-papier/</link>
      <pubDate>Wed, 18 Nov 2020 17:56:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2020-11-18-tmux-copier-coller-a-la-vi-&#43;-dans-le-presse-papier/</guid>
      <description>Commandes à ajouter au ~/.tmux.conf
Dans mon cas, il s&amp;rsquo;agit d&amp;rsquo;un tmux 1.8 :
bind-key P run-shell &amp;#34;xclip -o | tmux load-buffer - ; tmux paste-buffer&amp;#34; bind-key -t vi-copy &amp;#39;v&amp;#39; begin-selection bind-key -t vi-copy &amp;#39;y&amp;#39; copy-pipe &amp;#34;tmux save-buffer - | xclip -sel clip -i&amp;#34; bind-key -t vi-copy &amp;#39;r&amp;#39; rectangle-toggle Cela nécessite d&amp;rsquo;ajouter la commande xclip
Attention, l&amp;rsquo;exécution est très très lente&amp;hellip;</description>
    </item>
    
    <item>
      <title>commande, comparer des ensembles avec comm</title>
      <link>http://example.org/posts/2020-04-30-commande-comparer-des-ensembles-avec-comm/</link>
      <pubDate>Thu, 30 Apr 2020 15:54:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2020-04-30-commande-comparer-des-ensembles-avec-comm/</guid>
      <description>Parfois, on a besoin de comparer des ensembles. La commande comm permet de faire ressortir :
les valeurs qui n&amp;rsquo;appartiennent qu&amp;rsquo;au fichier f1 (colonne 1)
les valeurs qui n&amp;rsquo;appartiennent qu&amp;rsquo;au fichier f2 (colonne 2)
les valeurs qui appartiennent aux fichiers f1 et f2 (colonne 3)
1 pour faire disparaître la colonne 1 2 pour faire disparaître la colonne 2 3 pour faire disparaître la colonne 3 Attention, les fichiers doivent être au préalable triés.</description>
    </item>
    
    <item>
      <title>bash, lignes dupliquées</title>
      <link>http://example.org/posts/2019-07-09-bash-lignes-dupliquees/</link>
      <pubDate>Tue, 09 Jul 2019 15:52:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2019-07-09-bash-lignes-dupliquees/</guid>
      <description>Dans d&amp;rsquo;anciens post, j&amp;rsquo;avais parlé de la commande uniq
Il est possible de ne garder que les lignes dupliquées. Il faut utiliser l&amp;rsquo;option -d
$ for A in 1 3 4 2 3 1 1 1 3; do echo $A; done | sort | uniq -dc 4 1 3 3 </description>
    </item>
    
    <item>
      <title>awk</title>
      <link>http://example.org/posts/2019-07-09-awk/</link>
      <pubDate>Tue, 09 Jul 2019 15:44:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2019-07-09-awk/</guid>
      <description>Sur la version du DCG G3 (DCG : Dialog Code Generator)
/* &amp;lt;DCG_EXCEPTION id=&amp;#34;644&amp;#34; label=&amp;#34;idMenu = id du Choix Svi&amp;#34; type=&amp;#34;Action&amp;#34;&amp;gt; */ idMenu = getIdChoix(getSessionSvi(request), choixSvi); /* &amp;lt;/DCG_EXCEPTION&amp;gt; */ this.setReferenceInCtxSession( request, &amp;#34;idMenu&amp;#34;, idMenu ); addLog(request, &amp;#34;CONFIRM DDSLG_objId { Si537a2ba562f88b0ed24e8fab80913509366c055c }&amp;#34;); En migrant sur le DCG G4 on a :
/* &amp;lt;DCG_EXCEPTION id=&amp;#34;644&amp;#34; label=&amp;#34;idMenu = id du Choix Svi&amp;#34; type=&amp;#34;Action&amp;#34;&amp;gt; */ idMenu = getIdChoix(getSessionSvi(request), choixSvi); /* &amp;lt;/DCG_EXCEPTION&amp;gt; */ addLog(request, &amp;#34;CONFIRM DDSLG_objId { Si537a2ba562f88b0ed24e8fab80913509366c055c }&amp;#34;); La mise en session est donc perdue, ce qui provoque des erreurs dans le parcours client.</description>
    </item>
    
    <item>
      <title>socat, lien exemples</title>
      <link>http://example.org/posts/2019-07-04-socat-lien-exemples/</link>
      <pubDate>Thu, 04 Jul 2019 14:36:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2019-07-04-socat-lien-exemples/</guid>
      <description>http://technostuff.blogspot.com/2008/10/some-useful-socat-commands.html</description>
    </item>
    
    <item>
      <title>sed, garder les lignes qui matchent un pattern tout en faisant un remplacement</title>
      <link>http://example.org/posts/2019-01-15-sed-garder-les-lignes-qui-matchent-un-pattern-tout-en-faisant-un-remplacement/</link>
      <pubDate>Tue, 15 Jan 2019 16:38:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2019-01-15-sed-garder-les-lignes-qui-matchent-un-pattern-tout-en-faisant-un-remplacement/</guid>
      <description>$ cat /proc/cpuinfo | sed -rn &amp;#39;s/(fpu.*): (\w+)/\1 \2/gp&amp;#39; fpu	yes fpu_exception	yes fpu	yes fpu_exception	yes fpu	yes fpu_exception	yes fpu	yes fpu_exception	yes L&amp;rsquo;option -n permet de ne pas afficher les lignes tandis que l&amp;rsquo;ajout de /p indique d&amp;rsquo;afficher lors d&amp;rsquo;un matchage.</description>
    </item>
    
    <item>
      <title>bash, script seqdate</title>
      <link>http://example.org/posts/2018-10-17-bash-script-seqdate/</link>
      <pubDate>Wed, 17 Oct 2018 10:07:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2018-10-17-bash-script-seqdate/</guid>
      <description>Script réutilisable pour générer des dates avec date et seq
#!/bin/bash usage() { local msg=&amp;#34;$1&amp;#34; if [[ -n &amp;#34;$msg&amp;#34; ]]; then echo $msg fi echo &amp;#34;usage: $0 &amp;lt;FROM=YYYY-MM-DD&amp;gt; &amp;lt;TO=YYYY-MM-DD&amp;gt;&amp;#34; &amp;gt;&amp;amp;2 exit 1 } if [[ &amp;#34;$#&amp;#34; -ne 2 ]]; then usage fi FORMAT=&amp;#34;%Y-%m-%d&amp;#34; FROM=$(date --d &amp;#34;$1&amp;#34; +&amp;#34;$FORMAT&amp;#34;) TO=$(date --d &amp;#34;$2&amp;#34; +&amp;#34;$FORMAT&amp;#34;) if [[ &amp;#34;$FROM&amp;#34; &amp;gt; &amp;#34;$TO&amp;#34; ]]; then read FROM TO &amp;lt;&amp;lt;&amp;lt; &amp;#34;$TO $FROM&amp;#34; fi echo $FROM while [[ &amp;#34;$FROM&amp;#34; !</description>
    </item>
    
    <item>
      <title>bash, générer des dates avec les commandes seq et date</title>
      <link>http://example.org/posts/2018-10-16-bash-generer-des-dates-avec-les-commandes-seq-et-date/</link>
      <pubDate>Tue, 16 Oct 2018 11:28:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2018-10-16-bash-generer-des-dates-avec-les-commandes-seq-et-date/</guid>
      <description>Parfois il peut être utile d&amp;rsquo;avoir une liste de dates pour appeler un script particulier.
Cette liste peut être générée à partir des commandes seq et date comme dans l&amp;rsquo;exemple ci-dessous.
$ for i in $(seq 0 5); do date -d &amp;#34;20180705 $i day&amp;#34; +&amp;#39;%Y%m%d&amp;#39;; done 20180705 20180706 20180707 20180708 20180709 20180710 $ for i in $(seq 0 5); do date -d &amp;#34;20180705 $i day ago&amp;#34; +&amp;#39;%Y%m%d&amp;#39;; done 20180705 20180704 20180703 20180702 20180701 20180630 </description>
    </item>
    
    <item>
      <title>bash, select</title>
      <link>http://example.org/posts/2018-07-27-bash-select/</link>
      <pubDate>Fri, 27 Jul 2018 11:47:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2018-07-27-bash-select/</guid>
      <description>Je viens de m&amp;rsquo;apercevoir que je n&amp;rsquo;ai jamais parlé de la commande select sous bash. Celle-ci est très pratique car elle permet de faire un choix en précisant un numéro et non sa valeur.
Exemple d&amp;rsquo;utilisation ci-dessous :
$ select n in item1 item2 item3 item4 item5; do if [[ -n &amp;#34;$n&amp;#34; ]]; then echo &amp;#34;You choose: $n&amp;#34;; break; else echo &amp;#34;Invalid choice&amp;#34;; fi; done 1) item1 2) item2 3) item3 4) item4 5) item5 #?</description>
    </item>
    
    <item>
      <title>commande, history</title>
      <link>http://example.org/posts/2018-04-20-commande-history/</link>
      <pubDate>Fri, 20 Apr 2018 15:26:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2018-04-20-commande-history/</guid>
      <description>Parfois, on ne sait plus si on a relancé une commande dans le terminal&amp;hellip;
Pour avoir un historique daté, voici une petite configuration à ajouter à son .bashrc
export HISTTIMEFORMAT=&amp;#34;%d/%m %H:%M &amp;#34; Désormais, l&amp;rsquo;appel à l&amp;rsquo;historique produit des lignes avec les informations jour/mois heure/minute
$ history 492 19/04 16:15 cat ko | sed -e &amp;#39;s/.*(//&amp;#39; -e &amp;#39;s/ seconds.*//&amp;#39; -e &amp;#39;s/^[[:space:]]*$//;/^$/d&amp;#39; | awk &amp;#39;{SUM += $1} END {print &amp;#34;Total : &amp;#34;SUM}&amp;#39; 493 19/04 16:15 connect jenk </description>
    </item>
    
    <item>
      <title>sed, prefixer sur la première ligne et suffixer sur la dernière ligne sans modifier les lignes entre</title>
      <link>http://example.org/posts/2016-12-28-sed-prefixer-sur-la-premiere-ligne-et-suffixer-sur-la-derniere-ligne-sans-modifier-les-lignes-entre/</link>
      <pubDate>Wed, 28 Dec 2016 15:01:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-12-28-sed-prefixer-sur-la-premiere-ligne-et-suffixer-sur-la-derniere-ligne-sans-modifier-les-lignes-entre/</guid>
      <description>$ printf &amp;#34;lorem\nipsum\ndolores\nest&amp;#34; | sed -e &amp;#39;1s/^/&amp;lt;&amp;lt;/;$s/$/&amp;gt;&amp;gt;/;&amp;#39; &amp;lt;&amp;lt;lorem ipsum dolores est&amp;gt;&amp;gt; </description>
    </item>
    
    <item>
      <title>bash, gérer des archives de manière uniforme quelque soit le format de celles-ci</title>
      <link>http://example.org/posts/2016-10-13-bash-gerer-des-archives-de-maniere-uniforme-quelque-soit-le-format-de-celles-ci/</link>
      <pubDate>Thu, 13 Oct 2016 23:15:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-10-13-bash-gerer-des-archives-de-maniere-uniforme-quelque-soit-le-format-de-celles-ci/</guid>
      <description>En cherchant comment comparer deux archives, je suis tombé sur le paquet atool.
Celui-ci met à disposition :
un compacteur &amp;ldquo;universel&amp;rdquo; apack un décompacteur &amp;ldquo;universel&amp;rdquo; aunpack un outil pour recompacter dans un autre format arepack un outil pour comparer deux archives adiff La page suivante montre quelques exemples d&amp;rsquo;utilisation :
http://linoxide.com/linux-how-to/extracts-files-archive-atool-utility/</description>
    </item>
    
    <item>
      <title>sed, évaluer une commande bash lors du remplacement</title>
      <link>http://example.org/posts/2016-09-09-sed-evaluer-une-commande-bash-lors-du-remplacement/</link>
      <pubDate>Fri, 09 Sep 2016 16:53:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-09-09-sed-evaluer-une-commande-bash-lors-du-remplacement/</guid>
      <description>Je souhaitai décoder des valeurs encodées en base64 via sed.
Le paramètre final &amp;ldquo;/e&amp;rdquo; de sed permet d&amp;rsquo;évaluer l&amp;rsquo;expression remplacée.
Ici c&amp;rsquo;est la commande bash qui affiche l&amp;rsquo;attribut suivi d&amp;rsquo;un &amp;lsquo;:&amp;rsquo; et de la valeur décodée.
Comme vous le constatez, l&amp;rsquo;utilisation des valeurs capturées est possible.
$ cat /tmp/example.txt cn: John Doe @ Home displayName:: Sm9obiBEb2UK mail: johndoe@home.com $ cat /tmp/example.txt | sed -re &amp;#34;s/([^:]+):: (.*)$/echo \\1: \$(echo \\2 | base64 -d)/e&amp;#34; cn: John Doe @ Home displayName: John Doe mail: johndoe@home.</description>
    </item>
    
    <item>
      <title>base64, encoder/décoder sous bash</title>
      <link>http://example.org/posts/2016-09-09-base64-encoder-decoder-sous-bash/</link>
      <pubDate>Fri, 09 Sep 2016 15:11:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-09-09-base64-encoder-decoder-sous-bash/</guid>
      <description>On peut utiliser les programmes base64 (GNU coreutils) voir recode.
$ echo &amp;#34;Tralala pouet pouet&amp;#34; Tralala pouet pouet $ echo &amp;#34;Tralala pouet pouet&amp;#34; | base64 VHJhbGFsYSBwb3VldCBwb3VldAo= $ echo VHJhbGFsYSBwb3VldCBwb3VldAo= | base64 -d Tralala pouet pouet $ echo VHJhbGFsYSBwb3VldCBwb3VldAo= | recode /b64 Tralala pouet pouet $ echo &amp;#34;Tralala pouet pouet&amp;#34; | recode ../b64 VHJhbGFsYSBwb3VldCBwb3VldAo= </description>
    </item>
    
    <item>
      <title>sed, mettre sur une ligne après avoir matché un pattern</title>
      <link>http://example.org/posts/2016-09-09-sed-mettre-sur-une-ligne-apres-avoir-matche-un-pattern/</link>
      <pubDate>Fri, 09 Sep 2016 14:57:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-09-09-sed-mettre-sur-une-ligne-apres-avoir-matche-un-pattern/</guid>
      <description>h H Copy/append pattern space to hold space. g G Copy/append hold space to pattern space. n N Read/append the next line of input into the pattern space. (source: http://stackoverflow.com/questions/12833714/the-concept-of-hold-space-and-pattern-space-in-sed
La commande ldapsearch peut renvoyer des attributs avec leur valeur en base64 (présence :: après le nom de l&amp;rsquo;attribut) sur une ou plusieurs lignes (commençant par un espace).
Je souhaitais donc les merger facilement.
En regardant du côté de sed, il est possible de le faire facilement.</description>
    </item>
    
    <item>
      <title>recode, outil de conversion de jeux de caractères</title>
      <link>http://example.org/posts/2016-07-11-recode-outil-de-conversion-de-jeux-de-caracteres/</link>
      <pubDate>Mon, 11 Jul 2016 15:00:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-07-11-recode-outil-de-conversion-de-jeux-de-caracteres/</guid>
      <description>$ echo &amp;#39;a&amp;amp;lt;b&amp;amp;amp;&amp;amp;nbsp;c&amp;amp;eacute;&amp;#39; | recode html a&amp;lt;b&amp;amp; cé </description>
    </item>
    
    <item>
      <title>linux, connaître le modèle et numéro de série du PC sous linux</title>
      <link>http://example.org/posts/2016-07-06-linux-connaitre-le-modele-et-numero-de-serie-du-pc-sous-linux/</link>
      <pubDate>Wed, 06 Jul 2016 16:23:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-07-06-linux-connaitre-le-modele-et-numero-de-serie-du-pc-sous-linux/</guid>
      <description>sudo dmidecode -t system </description>
    </item>
    
    <item>
      <title>patch, en créer un et l&#39;appliquer</title>
      <link>http://example.org/posts/2016-05-11-patch-en-creer-un-et-l-appliquer/</link>
      <pubDate>Wed, 11 May 2016 11:26:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-05-11-patch-en-creer-un-et-l-appliquer/</guid>
      <description>Voici un exemple pour utiliser la commande patch :
svn diff &amp;gt; patch.diff svn revert -R . patch -p0 &amp;lt; patch.diff Parfois, elle peut-être utile. Ici c&amp;rsquo;est surtout pour retenir l&amp;rsquo;option -p0 que je poste cet article.</description>
    </item>
    
    <item>
      <title>sed/awk, remplacer plusieurs occurences entre deux balises html</title>
      <link>http://example.org/posts/2016-03-01-sed-awk-remplacer-plusieurs-occurences-entre-deux-balises-html/</link>
      <pubDate>Tue, 01 Mar 2016 11:27:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-03-01-sed-awk-remplacer-plusieurs-occurences-entre-deux-balises-html/</guid>
      <description>sed -ri &amp;#34;/&amp;lt;childProjects&amp;gt;/,/&amp;lt;\/childProjects&amp;gt;/ { s/monsvi-/MAINTENANCE-$GOROCO-monsvi-/g; }&amp;#34; $config_file Attention, il faut prendre garde au cas où les tags html ne seraient pas uniques :
$ cat text.txt &amp;lt;a&amp;gt; &amp;lt;b&amp;gt;toto&amp;lt;/b&amp;gt; &amp;lt;c&amp;gt;toto&amp;lt;/c&amp;gt; &amp;lt;b&amp;gt;toto&amp;lt;/b&amp;gt; &amp;lt;/a&amp;gt; $ cat text.txt | sed -r &amp;#39;/&amp;lt;b&amp;gt;/,/&amp;lt;\/b&amp;gt;/ { s/toto/t*t*/g; }&amp;#39; &amp;lt;a&amp;gt; &amp;lt;b&amp;gt;t*t*&amp;lt;/b&amp;gt; &amp;lt;c&amp;gt;t*t*&amp;lt;/c&amp;gt; &amp;lt;b&amp;gt;t*t*&amp;lt;/b&amp;gt; &amp;lt;/a&amp;gt; Si on a la chance que le tag de fin est sur la même ligne :
$ cat text.txt | sed -r &amp;#39;/&amp;lt;b&amp;gt;/,0 { s/toto/t*t*/g; }&amp;#39;&amp;lt;a&amp;gt; &amp;lt;b&amp;gt;t*t*&amp;lt;/b&amp;gt; &amp;lt;c&amp;gt;toto&amp;lt;/c&amp;gt; &amp;lt;b&amp;gt;t*t*&amp;lt;/b&amp;gt; &amp;lt;/a&amp;gt; Toutefois, je conseille de préférer awk dont le comportement est plus sûr.</description>
    </item>
    
    <item>
      <title>sed, garder ou retirer des lignes matchant un pattern spécifié</title>
      <link>http://example.org/posts/2016-01-20-sed-garder-ou-retirer-des-lignes-matchant-un-pattern-specifie/</link>
      <pubDate>Wed, 20 Jan 2016 11:36:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-01-20-sed-garder-ou-retirer-des-lignes-matchant-un-pattern-specifie/</guid>
      <description>Il est possible d&amp;rsquo;utiliser sed pour filter des lignes et garder/ne pas garder celles qui matchent un pattern spécifié
Dans l&amp;rsquo;exemple suivant, on garde ou ne garde pas les lignes contenant le terme ou
$ cat content.txt Ceci est un texte avec une tabulation avant ou bien deux espaces ou encore un mix des deux $ cat content.txt | sed &amp;#39;/ou/d&amp;#39; Ceci est un texte avec une tabulation avant $ cat content.</description>
    </item>
    
    <item>
      <title>Github, script de remplacement de chaines de caractères</title>
      <link>http://example.org/posts/2015-01-29-github-script-de-remplacement-de-chaines-de-caracteres/</link>
      <pubDate>Thu, 29 Jan 2015 21:39:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2015-01-29-github-script-de-remplacement-de-chaines-de-caracteres/</guid>
      <description>sed et awk sont très bien pour remplacer des chaines par d&amp;rsquo;autres.
Toutefois, le fait que ce soit des regexp qu&amp;rsquo;ils attendent complique l&amp;rsquo;utilisation lorsque la chaine fixe recherchée contient des caractères pouvant être interprétés comme des &amp;ldquo;opérateurs&amp;rdquo; de rexexp (? par exemple)
sandr est un outil qui permet de faire des recherches de chaines fixes ou non. Des options permettent d&amp;rsquo;extraire les chaines matchées/remplacées dans un fichier et d&amp;rsquo;appliquer des remplacements de masse (via une table de hachage).</description>
    </item>
    
    <item>
      <title>bash, swap de 2 fichiers</title>
      <link>http://example.org/posts/2012-09-25-bash-swap-de-2-fichiers/</link>
      <pubDate>Tue, 25 Sep 2012 13:50:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2012-09-25-bash-swap-de-2-fichiers/</guid>
      <description>Le code suivant à ajouter au bashrc permet de swapper ou plutôt échanger 2 fichiers rapidement.
function swap() { if [[ -e &amp;#34;$1&amp;#34; &amp;amp;&amp;amp; -e &amp;#34;$2&amp;#34; ]] # if files exist then local TMPFILE=$(tempfile) mv &amp;#34;$1&amp;#34; $TMPFILE mv &amp;#34;$2&amp;#34; &amp;#34;$1&amp;#34; mv $TMPFILE &amp;#34;$2&amp;#34; else echo &amp;#34;Error: Make sure the files exist.&amp;#34; fi } Et son exemple :
$ echo x&amp;gt;x $ echo y&amp;gt;y $ swap x e Error: Make sure the files exist.</description>
    </item>
    
    <item>
      <title>bash, mv en masse</title>
      <link>http://example.org/posts/2012-09-25-bash-mv-en-masse/</link>
      <pubDate>Tue, 25 Sep 2012 13:36:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2012-09-25-bash-mv-en-masse/</guid>
      <description>Il y a quelques années, j&amp;rsquo;avais écris un petit programme qui permettait de changer l&amp;rsquo;extension de fichiers.
A cette époque, je ne connaissais pas la commande mmv (comprendre &amp;ldquo;mass&amp;quot;mv) :
$ sudo apt-get install mmv $ ls -l *.abc -rw-r--r-- 1 root root 0 2012-09-25 13:34 x.abc -rw-r--r-- 1 root root 0 2012-09-25 13:34 y.abc -rw-r--r-- 1 root root 0 2012-09-25 13:34 zzz.abc $ mmv &amp;#34;*.abc&amp;#34; &amp;#34;#1.ABC&amp;#34; $ ls -l *.</description>
    </item>
    
    <item>
      <title>bash, tester si un programme est installé</title>
      <link>http://example.org/posts/2012-09-21-bash-tester-si-un-programme-est-installe/</link>
      <pubDate>Fri, 21 Sep 2012 10:03:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2012-09-21-bash-tester-si-un-programme-est-installe/</guid>
      <description>Pour tester si un programme est installé, on peut utiliser la commande which de différentes manières.
La première en comptabilisant le nombre de lignes retournées.
if [ $(which sponge | wc -l) -eq 0 ]; then echo &amp;#34;Installer le paquet &amp;#39;moreutils&amp;#39;.&amp;#34; echo &amp;#34;sudo apt-get install moreutils&amp;#34; exit 1 fi La seconde en utilisant le code de retour de la commande.
if ! which sponge &amp;gt;/dev/null; then echo &amp;#34;Installer le paquet &amp;#39;moreutils&amp;#39;.</description>
    </item>
    
    <item>
      <title>bash, lancer une commande à intervalle régulier</title>
      <link>http://example.org/posts/2012-06-28-bash-lancer-une-commande-a-intervalle-regulier/</link>
      <pubDate>Thu, 28 Jun 2012 11:13:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2012-06-28-bash-lancer-une-commande-a-intervalle-regulier/</guid>
      <description>watch -n 10 date </description>
    </item>
    
  </channel>
</rss>
