<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sed on Mezalor</title>
    <link>http://example.org/tags/sed/</link>
    <description>Recent content in sed on Mezalor</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <lastBuildDate>Thu, 04 Mar 2021 14:50:00 +0100</lastBuildDate><atom:link href="http://example.org/tags/sed/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>grep, extraire des données</title>
      <link>http://example.org/posts/2021-03-04-grep-extraire-des-donnees/</link>
      <pubDate>Thu, 04 Mar 2021 14:50:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2021-03-04-grep-extraire-des-donnees/</guid>
      <description>Il est possible d&amp;rsquo;utiliser grep pour extraire des données.
Dans l&amp;rsquo;exemple qui suit, on récupère le nom des compagnies dans un fichier json.
s=&amp;#39;[{&amp;#34;_id&amp;#34;:&amp;#34;6040e2f5ed4a6976ab0e8719&amp;#34;,&amp;#34;index&amp;#34;:0,&amp;#34;guid&amp;#34;:&amp;#34;5b71d966-1df3-4f22-8941-27d83e0181f2&amp;#34;,&amp;#34;isActive&amp;#34;:true,&amp;#34;balance&amp;#34;:&amp;#34;$2,464.05&amp;#34;,&amp;#34;picture&amp;#34;:&amp;#34;http://placehold.it/32x32&amp;#34;,&amp;#34;age&amp;#34;:36,&amp;#34;eyeColor&amp;#34;:&amp;#34;brown&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;House Hays&amp;#34;,&amp;#34;gender&amp;#34;:&amp;#34;male&amp;#34;,&amp;#34;company&amp;#34;:&amp;#34;WEBIOTIC&amp;#34;,&amp;#34;email&amp;#34;:&amp;#34;househays@webiotic.com&amp;#34;,&amp;#34;phone&amp;#34;:&amp;#34;+1 (921) 461-3048&amp;#34;,&amp;#34;address&amp;#34;:&amp;#34;246 Butler Street, Lydia, Federated States Of Micronesia, 8224&amp;#34;,&amp;#34;about&amp;#34;:&amp;#34;Labore proident eu non dolor reprehenderit et qui et pariatur. Consectetur quis incididunt aliqua cupidatat exercitation ex nulla ullamco reprehenderit deserunt. Velit cillum elit esse eu eiusmod cupidatat in fugiat ullamco. Labore labore officia minim sunt do.</description>
    </item>
    
    <item>
      <title>sed, remplacer une ligne qui matche</title>
      <link>http://example.org/posts/2020-12-01-sed-remplacer-une-ligne-qui-matche/</link>
      <pubDate>Tue, 01 Dec 2020 11:16:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2020-12-01-sed-remplacer-une-ligne-qui-matche/</guid>
      <description>Voici comment remplacer une ligne qui matche avec la commande sed
$ printf &amp;#34;[section1]\\n\\n[section2]\\ncle1=valeur1\\n&amp;#34; | sed &amp;#39;/^\\[section2\\]/c cle2=valeur2&amp;#39; [section1] cle2=valeur2 cle1=valeur1 </description>
    </item>
    
    <item>
      <title>sed, insérer avant ou après matchage de ligne</title>
      <link>http://example.org/posts/2020-12-01-sed-inserer-avant-ou-apres-matchage-de-ligne/</link>
      <pubDate>Tue, 01 Dec 2020 11:15:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2020-12-01-sed-inserer-avant-ou-apres-matchage-de-ligne/</guid>
      <description>Peut-être pratique pour modifier un fichier de configuration par exemple
$ printf &amp;#34;[section1]\\n\\n[section2]\\ncle1=valeur1\\n&amp;#34; | sed &amp;#39;/^\\[section2\\]/i cle2=valeur2&amp;#39; [section1] cle2=valeur2 [section2] cle1=valeur1 $ printf &amp;#34;[section1]\\n\\n[section2]\\ncle1=valeur1\\n&amp;#34; | sed &amp;#39;/^\\[section2\\]/a cle2=valeur2&amp;#39; [section1] [section2] cle2=valeur2 cle1=valeur1 </description>
    </item>
    
    <item>
      <title>sed, prefixer sur la première ligne et suffixer sur la dernière ligne sans modifier les lignes entre</title>
      <link>http://example.org/posts/2016-12-28-sed-prefixer-sur-la-premiere-ligne-et-suffixer-sur-la-derniere-ligne-sans-modifier-les-lignes-entre/</link>
      <pubDate>Wed, 28 Dec 2016 15:01:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-12-28-sed-prefixer-sur-la-premiere-ligne-et-suffixer-sur-la-derniere-ligne-sans-modifier-les-lignes-entre/</guid>
      <description>$ printf &amp;#34;lorem\nipsum\ndolores\nest&amp;#34; | sed -e &amp;#39;1s/^/&amp;lt;&amp;lt;/;$s/$/&amp;gt;&amp;gt;/;&amp;#39; &amp;lt;&amp;lt;lorem ipsum dolores est&amp;gt;&amp;gt; </description>
    </item>
    
    <item>
      <title>bash, composer une url depuis une url de référence avec sed</title>
      <link>http://example.org/posts/2016-09-21-bash-composer-une-url-depuis-une-url-de-reference-avec-sed/</link>
      <pubDate>Wed, 21 Sep 2016 17:08:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-09-21-bash-composer-une-url-depuis-une-url-de-reference-avec-sed/</guid>
      <description>$ link=&amp;#34;https://www.example.com/path/to/somewhere?q=xxx&amp;#34; $ new_link=&amp;#34;$(echo $link | sed -rn &amp;#39;s#([^:]*://[^/]*)/.*#\1#p&amp;#39;)/another/path/to/somewhere?qq=yyy&amp;#34; $ echo $new_link https://www.example.com/another/path/to/somewhere?qq=yyy </description>
    </item>
    
    <item>
      <title>sed, évaluer une commande bash lors du remplacement</title>
      <link>http://example.org/posts/2016-09-09-sed-evaluer-une-commande-bash-lors-du-remplacement/</link>
      <pubDate>Fri, 09 Sep 2016 16:53:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-09-09-sed-evaluer-une-commande-bash-lors-du-remplacement/</guid>
      <description>Je souhaitai décoder des valeurs encodées en base64 via sed.
Le paramètre final &amp;ldquo;/e&amp;rdquo; de sed permet d&amp;rsquo;évaluer l&amp;rsquo;expression remplacée.
Ici c&amp;rsquo;est la commande bash qui affiche l&amp;rsquo;attribut suivi d&amp;rsquo;un &amp;lsquo;:&amp;rsquo; et de la valeur décodée.
Comme vous le constatez, l&amp;rsquo;utilisation des valeurs capturées est possible.
$ cat /tmp/example.txt cn: John Doe @ Home displayName:: Sm9obiBEb2UK mail: johndoe@home.com $ cat /tmp/example.txt | sed -re &amp;#34;s/([^:]+):: (.*)$/echo \\1: \$(echo \\2 | base64 -d)/e&amp;#34; cn: John Doe @ Home displayName: John Doe mail: johndoe@home.</description>
    </item>
    
    <item>
      <title>sed, mettre sur une ligne après avoir matché un pattern</title>
      <link>http://example.org/posts/2016-09-09-sed-mettre-sur-une-ligne-apres-avoir-matche-un-pattern/</link>
      <pubDate>Fri, 09 Sep 2016 14:57:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-09-09-sed-mettre-sur-une-ligne-apres-avoir-matche-un-pattern/</guid>
      <description>h H Copy/append pattern space to hold space. g G Copy/append hold space to pattern space. n N Read/append the next line of input into the pattern space. (source: http://stackoverflow.com/questions/12833714/the-concept-of-hold-space-and-pattern-space-in-sed
La commande ldapsearch peut renvoyer des attributs avec leur valeur en base64 (présence :: après le nom de l&amp;rsquo;attribut) sur une ou plusieurs lignes (commençant par un espace).
Je souhaitais donc les merger facilement.
En regardant du côté de sed, il est possible de le faire facilement.</description>
    </item>
    
    <item>
      <title>sed, supprimer une ou des lignes en fonction de leurs numéros</title>
      <link>http://example.org/posts/2016-07-12-sed-supprimer-une-ou-des-lignes-en-fonction-de-leurs-numeros/</link>
      <pubDate>Tue, 12 Jul 2016 10:36:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-07-12-sed-supprimer-une-ou-des-lignes-en-fonction-de-leurs-numeros/</guid>
      <description>Il est possible d&amp;rsquo;utiliser sed pour supprimer une ligne en fonction de son numéro ou un ensemble de lignes défini par le numéro de ligne de départ et de fin.
Voici un exemple :
$ free total used free shared buffers cached Mem: 11997816 4512068 7485748 360084 283812 1716000 -/+ buffers/cache: 2512256 9485560 Swap: 12270588 0 12270588 $ free | sed &amp;#39;2d&amp;#39; total used free shared buffers cached -/+ buffers/cache: 2514236 9483580 Swap: 12270588 0 12270588 $ free | sed &amp;#39;2,3d&amp;#39; total used free shared buffers cached Swap: 12270588 0 12270588 Ceci permet d&amp;rsquo;éviter de jouer avec une succession de head/tail&amp;hellip;</description>
    </item>
    
    <item>
      <title>sed/awk, remplacer plusieurs occurences entre deux balises html</title>
      <link>http://example.org/posts/2016-03-01-sed-awk-remplacer-plusieurs-occurences-entre-deux-balises-html/</link>
      <pubDate>Tue, 01 Mar 2016 11:27:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-03-01-sed-awk-remplacer-plusieurs-occurences-entre-deux-balises-html/</guid>
      <description>sed -ri &amp;#34;/&amp;lt;childProjects&amp;gt;/,/&amp;lt;\/childProjects&amp;gt;/ { s/monsvi-/MAINTENANCE-$GOROCO-monsvi-/g; }&amp;#34; $config_file Attention, il faut prendre garde au cas où les tags html ne seraient pas uniques :
$ cat text.txt &amp;lt;a&amp;gt; &amp;lt;b&amp;gt;toto&amp;lt;/b&amp;gt; &amp;lt;c&amp;gt;toto&amp;lt;/c&amp;gt; &amp;lt;b&amp;gt;toto&amp;lt;/b&amp;gt; &amp;lt;/a&amp;gt; $ cat text.txt | sed -r &amp;#39;/&amp;lt;b&amp;gt;/,/&amp;lt;\/b&amp;gt;/ { s/toto/t*t*/g; }&amp;#39; &amp;lt;a&amp;gt; &amp;lt;b&amp;gt;t*t*&amp;lt;/b&amp;gt; &amp;lt;c&amp;gt;t*t*&amp;lt;/c&amp;gt; &amp;lt;b&amp;gt;t*t*&amp;lt;/b&amp;gt; &amp;lt;/a&amp;gt; Si on a la chance que le tag de fin est sur la même ligne :
$ cat text.txt | sed -r &amp;#39;/&amp;lt;b&amp;gt;/,0 { s/toto/t*t*/g; }&amp;#39;&amp;lt;a&amp;gt; &amp;lt;b&amp;gt;t*t*&amp;lt;/b&amp;gt; &amp;lt;c&amp;gt;toto&amp;lt;/c&amp;gt; &amp;lt;b&amp;gt;t*t*&amp;lt;/b&amp;gt; &amp;lt;/a&amp;gt; Toutefois, je conseille de préférer awk dont le comportement est plus sûr.</description>
    </item>
    
    <item>
      <title>sed, garder ou retirer des lignes matchant un pattern spécifié</title>
      <link>http://example.org/posts/2016-01-20-sed-garder-ou-retirer-des-lignes-matchant-un-pattern-specifie/</link>
      <pubDate>Wed, 20 Jan 2016 11:36:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2016-01-20-sed-garder-ou-retirer-des-lignes-matchant-un-pattern-specifie/</guid>
      <description>Il est possible d&amp;rsquo;utiliser sed pour filter des lignes et garder/ne pas garder celles qui matchent un pattern spécifié
Dans l&amp;rsquo;exemple suivant, on garde ou ne garde pas les lignes contenant le terme ou
$ cat content.txt Ceci est un texte avec une tabulation avant ou bien deux espaces ou encore un mix des deux $ cat content.txt | sed &amp;#39;/ou/d&amp;#39; Ceci est un texte avec une tabulation avant $ cat content.</description>
    </item>
    
    <item>
      <title>Github, script de remplacement de chaines de caractères</title>
      <link>http://example.org/posts/2015-01-29-github-script-de-remplacement-de-chaines-de-caracteres/</link>
      <pubDate>Thu, 29 Jan 2015 21:39:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2015-01-29-github-script-de-remplacement-de-chaines-de-caracteres/</guid>
      <description>sed et awk sont très bien pour remplacer des chaines par d&amp;rsquo;autres.
Toutefois, le fait que ce soit des regexp qu&amp;rsquo;ils attendent complique l&amp;rsquo;utilisation lorsque la chaine fixe recherchée contient des caractères pouvant être interprétés comme des &amp;ldquo;opérateurs&amp;rdquo; de rexexp (? par exemple)
sandr est un outil qui permet de faire des recherches de chaines fixes ou non. Des options permettent d&amp;rsquo;extraire les chaines matchées/remplacées dans un fichier et d&amp;rsquo;appliquer des remplacements de masse (via une table de hachage).</description>
    </item>
    
    <item>
      <title>bash, récupérer la n-ième ligne ou les lignes x à y d&#39;un fichier</title>
      <link>http://example.org/posts/2012-10-17-bash-recuperer-la-n-ieme-ligne-ou-les-lignes-x-a-y-d-un-fichier/</link>
      <pubDate>Wed, 17 Oct 2012 11:05:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2012-10-17-bash-recuperer-la-n-ieme-ligne-ou-les-lignes-x-a-y-d-un-fichier/</guid>
      <description>On peut utiliser awk avec NR (numéro de ligne tout fichier confondus) ou FNR (numéro de ligne du fichier) :
### afficher la 3e ligne $ awk &amp;#39;NR==3 { print; exit; }&amp;#39; /etc/passwd bin:x:2:2:bin:/bin:/bin/sh ### afficher les lignes 3 à 6 $ awk &amp;#39;3&amp;lt;=NR &amp;amp;&amp;amp; NR&amp;lt;=6 { print; }&amp;#39; /etc/passwd bin:x:2:2:bin:/bin:/bin/sh sys:x:3:3:sys:/dev:/bin/sh sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/bin/sh Ou bien avec sed :
$ cat /etc/passwd | sed &amp;#39;3!d&amp;#39; bin:x:2:2:bin:/bin:/usr/sbin/nologin $ cat /etc/passwd | sed &amp;#39;3,6!</description>
    </item>
    
    <item>
      <title>bash, supprimer les lignes vides d&#39;un fichier</title>
      <link>http://example.org/posts/2012-10-17-bash-supprimer-les-lignes-vides-d-un-fichier/</link>
      <pubDate>Wed, 17 Oct 2012 10:06:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2012-10-17-bash-supprimer-les-lignes-vides-d-un-fichier/</guid>
      <description>Voici plusieurs solutions
$ cat ~/fichier | sed -e &amp;#39;s/^[[:space:]]*$//;/^$/d&amp;#39; $ cat ~/fichier | awk NF où NF indique le nombre de champs. Si ce n&amp;rsquo;est pas une ligne vide, le nombre de champs est positif et la commande par défaut de awk est d&amp;rsquo;afficher. Ce qui équivaut à :
$ cat ~/fichier | awk &amp;#39;NF!=0 { print }&amp;#39; </description>
    </item>
    
    <item>
      <title>bash, supprimer les tags html avec sed...</title>
      <link>http://example.org/posts/2012-09-06-bash-supprimer-les-tags-html-avec-sed/</link>
      <pubDate>Thu, 06 Sep 2012 10:29:00 +0100</pubDate>
      
      <guid>http://example.org/posts/2012-09-06-bash-supprimer-les-tags-html-avec-sed/</guid>
      <description>Dans certains scripts bash, on peut souhaiter supprimer les tags html d&amp;rsquo;un flux ou d&amp;rsquo;un fichier. Pour cela on peut utiliser la commande sed.
$ echo $texte &amp;lt;div class=&amp;#39;descriptionwrapper&amp;#39;&amp;gt; &amp;lt;p class=&amp;#39;description&amp;#39;&amp;gt;&amp;lt;span&amp;gt;J&amp;#39;entrepose ici mes découvertes linux, bash, python et java que je souhaite partager et mettre de côté...&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; $ texte | sed -e &amp;#39;s/&amp;lt;[^&amp;gt;]*&amp;gt;//g&amp;#39; J&amp;#39;entrepose ici mes découvertes linux, bash, python et java que je souhaite partager et mettre de côté.</description>
    </item>
    
  </channel>
</rss>
